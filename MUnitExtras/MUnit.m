(* ::Package:: *)

BeginPackage["MUnitExtras`MUnit`", {"MUnit`"}]


(* ::Section:: *)
(*Public*)


UnevaluatadExpectedOutput::usage =
"\
UnevaluatadExpectedOutput \
is a selector for TestResult that returns unevaluated expected output wrapped \
in HoldForm."


UnevaluatadRawExpectedOutput::usage =
"\
UnevaluatadRawExpectedOutput \
is a selector for TestResult that returns unevaluated expected argument that \
was given to test wrapped in HoldForm."


TestRawInput::usage =
"\
TestRawInput \
is a selector for TestResult that returns unevaluated input argument that was \
given to test wrapped in HoldForm."


TestFailureMessageGenerator::usage =
"\
TestFailureMessageGenerator \
is an option to Test that specifies a function used to generate failure \
message that will be logged if the test fails. This function will be called \
with one argument: test result object.

TestFailureMessageGenerator is also a selector for TestResult."


ApplyToInput::usage =
"\
ApplyToInput \
is an option to Test that, if different than None, specifies a function \
applied to input before evaluating it in Test.

ApplyToInput is also a selector for TestResult."


ApplyToExpected::usage =
"\
ApplyToExpected \
is an option to Test that, if different than None, specifies a function \
applied to expected value, given to Test, before evaluating it.

ApplyToExpected is also a selector for TestResult."


InputWrapper::usage =
"\
InputWrapper \
is an option to Test that, if different than None, specifies a function to \
wrap input before evaluating it in Test.

InputWrapper is also a selector for TestResult."


ExpectedWrapper::usage =
"\
ExpectedWrapper \
is an option to Test that, if different than None, specifies a function to \
wrap expected value, given to Test, before evaluating it.

ExpectedWrapper is also a selector for TestResult."


$DefaultTestFailureMessageGenerator::usage =
"\
$DefaultTestFailureMessageGenerator[tr] \
is called to generate final TestFailureMessage for given test result tr."


$FailureMessagesLength::usage =
"\
$FailureMessagesLength \
should be an integer, it denotes maximal number of characters that failure \
message can have."


(* Unprotect all public symbols in this package. *)
Unprotect["`*"];


(* ::Section:: *)
(*Private*)


Begin["`Private`"]


(* ::Subsection:: *)
(*Imports*)


Needs["ProtectionUtilities`"] (* ProtectContextNonVariables *)
Needs["OptionsUtilities`"] (* PrependToOptions *)
Needs["StringUtilities`"] (* StringJoinBy *)


(* ::Subsection:: *)
(*ApplyAndWrapInsideHold*)


ApplyAndWrapInsideHold[
	holdExpr:(_HoldComplete | _Hold | _HoldPattern | _HoldForm),
	apply_, wrap_
] :=
	Switch[{apply, wrap},
		{None, None},
			holdExpr
		,
		{_, None},
			(*
				Since input is wrapped with Hold we apply function at level 1.
			*)
			apply @@@ holdExpr
		,
		{None, _},
			(*
				Since input is wrapped with Hold we map function at holdInput,
				not just wrapp it.
			*)
			wrap /@ holdExpr
		,
		_,
			wrap /@ (apply @@@ holdExpr)
	]


(* ::Subsection:: *)
(*$FailureMessagesLength*)


$FailureMessagesLength = 200


(* ::Subsection:: *)
(*LimitFailureMessageLenght*)


LimitFailureMessageLenght[msg_String] :=
	If[StringLength[msg] > $FailureMessagesLength,
		StringTake[msg, $FailureMessagesLength - 3] <> "..."
	(* else *),
		msg
	]


(* ::Subsection:: *)
(*RemoveSameQWithTrue*)


RemoveSameQWithTrue[HoldForm[SameQ[input_, "True"]]] := HoldForm[input]

RemoveSameQWithTrue[arg_] := arg


(* ::Subsection:: *)
(*DefaultFailureMessageGenerator*)


DefaultFailureMessageGenerator[tr_?TestResultQ] :=
	With[
		{
			failureMessageStr = ToString[TestFailureMessage[tr]],
			input = MeetLogger`Private`makeString[TestInput[tr]]
			,
			expected = MeetLogger`Private`makeString[UnevaluatadExpectedOutput[tr]],
			equivalenceFunction = EquivalenceFunction[tr],
			prefix =
				Switch[FailureMode[tr],
					"Failure",
						"Not true that: "
					,
					"MessagesFailure",
						"Incorrect messages generated by: "
					,
					_,
						""
				]
		}
		,
		LimitFailureMessageLenght[
			StringJoinBy[
				failureMessageStr
				,
				prefix <>
					ToString[
						RemoveSameQWithTrue[
							HoldForm[equivalenceFunction[input, expected]]
						]
					]
				,
				"Separator" -> " | "
			]
		]
	]


(* ::Subsection:: *)
(*$DefaultTestFailureMessageGenerator*)


$DefaultTestFailureMessageGenerator = DefaultFailureMessageGenerator
	


(* ::Section:: *)
(*MUnit`Test`Private` modifications*)


(*
	Code added to MUnit`Test`Private` context is marked with
	BEGIN/END ADDED/CHANGED CODE
*)
Begin["MUnit`Test`Private`"]


(* BEGIN ADDED CODE *)
AppendTo[$ContextPath, "MUnit`Package`"];
AppendTo[$ContextPath, "MUnitExtras`MUnit`Private`"];



PrependToOptions[#,
	TestFailureMessageGenerator -> $DefaultTestFailureMessageGenerator
	,
	(# -> None)& /@
		{ApplyToInput, ApplyToExpected, InputWrapper, ExpectedWrapper}
]& /@ {
	TestResultObject,
	(* Tests from MUnit/Test. *)
	Test, TestMatch, TestStringMatch, TestFree, TestStringFree,
	(* Tests from MUnit/WRI.m *)
	ConditionalTest, ExactTest, ExactTestCaveat, NTest, NTestCaveat,
	OrTest, TestCaveat
}
(* END ADDED CODE *)


Test[input_, expected_:True, Shortest[expectedMsgs_:{}], opts:OptionsPattern[]] :=
	Module[{
(* BEGIN ADDED CODE *)
		holdPreprocessedInput, applyToInput, inputWrapper,
		holdPreprocessedExpected, applyToExpected, expectedWrapper,
		testFailureMessageGenerator,
(* END ADDED CODE *)
		actualOutputSetFunction, expectedOutputSetFunction, testEquivFunc, msgsEquivFunc,
		expectedOutputWrapper, actualOutputWrapper, expectedMsgsWrapper, testID, actual,
		expectedEvaled, testEquivFuncEvaled, msgsEquivFuncEvaled, actualMsgs, expectedOutputMsgs, testEquivFuncMsgStrings, msgsEquivFuncMsgStrings,
		failureMode, testFailureMessage,
		testFailureAction, testErrorAction,
		timeConstraint, memoryConstraint, timeUsed, memoryUsed, testTags, actualRes, expectedRes,
		testEquivFuncRes, msgsEquivFuncRes},
		Catch[
			Block[{
				(*
				$Messages needs to be something not likely to be set by a function blocking messages, like no-value $Messages or {},
				in order to be able to tell when it IS set to $Messages or {}, in order to correctly not report those messages
				But it also needs to be something not containing stdout, to ACTUALLY suppress all messages
				It also needs to be something that actually works as a OutputStream, like a temp file, otherwise there is a slew of messages
				complaining.
				But there's no reason to open a whole temp file just for one test. Just use the platform-dependent bitbucket
				Now, we'll know if $Messages was changed because it will no longer be {$bitbucket}, a safe bet.
				Who would be writing to the bitbucket in a normal circumstance?
				If there were a way to have a MUnit-specific bitbucket, that would be great. Or to have virtual stream things in Mathematica.
				*)
				$Messages = {$bitbucket},
				(* Block these symbols to minimize side-effects *)			
				$DisplayFunction = Identity,
				$SoundDisplayFunction = Identity,
				(* these are to setup a nice environment for tests within tests! *)
				$actualTestIndex = 0,
				$allTestIndex = 0,
				$MessageWithArgsList = {},
				(* even though we don't use it, continue blocking $MessageList. This is to reset the General::stop counter
				and allow
				t:=Test[1/0,ComplexInfinity,{_}];
				{t,t,t}
				to work*)
				$MessageList = {},
				MUnitMessageHandler = $MUnitMessageHandler}
				,
	
				(* treat any unrecognized options as an error *)
				Check[
					{
(* BEGIN ADDED CODE *)
						applyToInput, inputWrapper,
						applyToExpected, expectedWrapper,
						testFailureMessageGenerator,
(* END ADDED CODE *)
						actualOutputSetFunction, expectedOutputSetFunction, testEquivFunc, msgsEquivFunc,
						expectedOutputWrapper, actualOutputWrapper, expectedMsgsWrapper, testID, testFailureMessage,
						testFailureAction, testErrorAction, timeConstraint, memoryConstraint, testTags} =
						OptionValue[{
(* BEGIN ADDED CODE *)
							ApplyToInput, InputWrapper,
							ApplyToExpected, ExpectedWrapper,
							TestFailureMessageGenerator,
(* END ADDED CODE *)
							ActualOutputSetFunction, ExpectedOutputSetFunction, EquivalenceFunction,
							MessagesEquivalenceFunction,
							ExpectedOutputWrapper, ActualOutputWrapper,
							ExpectedMessagesWrapper, TestID, TestFailureMessage,
							TestFailureAction, TestErrorAction,
							TimeConstraint, MemoryConstraint, TestTags}]
					,
					Throw["Invalid options: " <> ToString[FilterRules[Flatten[{opts},1], Except[Options[Test]]]], "internalMUnitTestTag"]
					,
					OptionValue::nodef
				];
				
				memoryUsed = MemoryInUse[];
				timeUsed = TimeUsed[];
				
(* BEGIN ADDED CODE *)
				holdPreprocessedInput = ApplyAndWrapInsideHold[HoldComplete[input], applyToInput, inputWrapper];
(* END ADDED CODE *)
				actualRes = MUnitCheckAll[
					actualOutputSetFunction[
						actual
						,
(* BEGIN CHANGED CODE: WAS *)
(*						input*)
(* CHANGED CODE: IS *)
						ReleaseHold[holdPreprocessedInput]
(* END CHANGED CODE *)
					]
					,
					opts
				];
				If[MatchQ[actualRes, $TimeConstrained | $MemoryConstrained],
					actual = actualRes 
				];
				
				timeUsed = TimeUsed[] - timeUsed;
				memoryUsed = MemoryInUse[] - memoryUsed;
				
				actualMsgs = $MessageWithArgsList;
				$MessageWithArgsList = {};
				$MessageList = {};
				
(* BEGIN ADDED CODE *)
				holdPreprocessedExpected = ApplyAndWrapInsideHold[HoldComplete[expected], applyToExpected, expectedWrapper];
(* END ADDED CODE *)
				expectedRes = MUnitCheckAll[
					expectedOutputSetFunction[
						expectedEvaled
						,
(* BEGIN CHANGED CODE: WAS *)
(*						expected*)
(* CHANGED CODE: IS *)
						ReleaseHold[holdPreprocessedExpected]
(* END CHANGED CODE *)
					]
					,
					opts
				];
				If[MatchQ[expectedRes, $TimeConstrained | $MemoryConstrained],
					expectedEvaled = expectedRes 
				];
				
				expectedOutputMsgs = $MessageWithArgsList;
				$MessageWithArgsList = {};
				$MessageList = {};
				
				
				Block[{MUnitMessageHandler = messageStringHandler},
					$MessageStringList = {};
					
					testEquivFuncRes = MUnitCheckAll[
						Set[
							testEquivFuncEvaled
							,
							testEquivFunc[actual, expectedEvaled]
						]
						,
						opts
					];
					
					testEquivFuncMsgStrings = $MessageStringList;
					$MessageStringList = {};
					$MessageList = {};
					
					(*
					TODO:
					if using $DefaultExpectedMessageHandler and given MessageNames as expected messages,
					then make sure to return MessagesNames as the actual messages
					*)
					msgsEquivFuncRes = MUnitCheckAll[
						Set[
							msgsEquivFuncEvaled
							,
							msgsEquivFunc[actualMsgs, expectedMsgs]
						]
						,
						opts
					];
					
					msgsEquivFuncMsgStrings = $MessageStringList;
					$MessageStringList = {};
					$MessageList = {};
				];
				
				failureMode = determineFailureMode[
								{testEquivFuncEvaled, msgsEquivFuncEvaled},
								{testEquivFuncRes, msgsEquivFuncRes},
								{testEquivFuncMsgStrings, msgsEquivFuncMsgStrings}]
				
			]; (* end Block *)
			(*
			Wrap expected and actual in HoldForm to preserve it. This is neccessary if a TestResultObject is saved to a file,
			then read in a different session, where actual would evaluate to something new.
			*)
			Module[{tr},
				tr = Sow[
					newTestResultObject[
						HoldForm[Test[input, expected, expectedMsgs, opts]],
						failureMode,
						HoldForm[input],
(* BEGIN ADDED CODE *)
						HoldForm @@ holdPreprocessedInput,
						HoldForm[expected],
						HoldForm @@ holdPreprocessedExpected,
(* END ADDED CODE *)
						(* this makes sure that if expectedEvaled or actual are delayed, then they are maintained *)
						expectedOutputWrapper[expectedEvaled],
						actualOutputWrapper[actual],
						expectedMsgsWrapper[expectedMsgs],
						(* each msg is already wrapped in HoldForm *)
						actualMsgs,
						"",
						TestIndex -> ++$actualTestIndex,
						AllTestIndex -> $allTestIndex,
						TestID -> testID,
(* BEGIN ADDED CODE *)
						ApplyToInput -> applyToInput,
						ApplyToExpected -> applyToExpected,
						InputWrapper -> inputWrapper,
						ExpectedWrapper -> expectedWrapper,
						TestFailureMessageGenerator -> testFailureMessageGenerator,
(* END ADDED CODE *)
						ActualOutputSetFunction -> actualOutputSetFunction,
						ExpectedOutputSetFunction -> expectedOutputSetFunction,
						EquivalenceFunction -> testEquivFunc,
						MessagesEquivalenceFunction -> msgsEquivFunc,
						ExpectedMessagesWrapper -> expectedMsgsWrapper,
						TestFailureMessage -> testFailureMessage,
						TestFailureAction -> testFailureAction,
						TestErrorAction -> testErrorAction,
						TestTimeUsed -> timeUsed,
						TestMemoryUsed -> memoryUsed,
						TestTags -> testTags,
						TestSource -> $CurrentTestSource
					],
					{"MUnitTest"}
				];
				logTestResult[tr];
				tr
			]
			,
			"internalMUnitTestTag"
			,
			Function[{value, tag},
				(*
				calling testError must wait until outside of the Block, so that $actualTestIndex can increment correctly
				*)
				testError[value, opts]
			]
		]
	]


testError[errMsg_String, ___, opts:OptionsPattern[]] :=
	Module[{testID, testErrorAction, tr},
		Quiet[{testID, testErrorAction} = OptionValue[Test, {opts}, {TestID, TestErrorAction}], {OptionValue::nodef}];
		tr = Sow[
			newTestResultObject[
				$Error,
				"Error",
				$Error,
(* BEGIN ADDED CODE *)
				$Error,
				$Error,
				$Error,
(* END ADDED CODE *)
				$Error,
				$Error,
				$Error,
				$Error,
				errMsg,
				TestIndex -> ++$actualTestIndex,
				AllTestIndex -> $allTestIndex,
				TestID -> testID,
(* BEGIN ADDED CODE *)
				TestErrorAction -> testErrorAction,
(* END ADDED CODE *)
				TestSource -> $CurrentTestSource
			]
			,
			{"MUnitTest"}
		];
		logTestResult[tr];
		tr
	]


newTestResultObject[
	test_,
	failureMode_,
(* BEGIN ADDED CODE *)
	rawInput_,
(* END ADDED CODE *)
	input_,
(* BEGIN ADDED CODE *)
	unevaluatedRawExpectedOutput_,
	unevaluatedExpectedOutput_,
(* END ADDED CODE *)
	expectedOutput_,
	actualOutput_,
	expectedMsgs_,
	actualMsgs_,
	errorMsg_,
	opts:OptionsPattern[]] :=
	With[{obj = Unique["MUnit`TestResultObjects`TestResultObject"]},
		Module[{},
			obj /: TestResultQ[obj] = True;
			obj /: Format[obj, OutputForm] :=
				Switch[FailureMode[obj],
					"Success",
					StringJoin["-", "Success", "-"]
					,					
					"MessagesFailure",
					StringJoin["-", "MessagesFailure: ", ToString[ActualMessages[obj], OutputForm], "-"]
					,
					"Failure",
					StringJoin["-", "Failure: ", ToString[ActualOutput[obj], OutputForm], "-"]
					,
					"Error",
					StringJoin["-", "Error: ", ErrorMessage[obj], "-"]
				];
			obj /: Format[obj, StandardForm] :=
				Switch[FailureMode[obj],
					"Success",
					Interpretation[Row[{RawBoxes["\[SkeletonIndicator]"], Row[{RawBoxes["TestResultObject"], RawBoxes["["], "Success", RawBoxes["]"]}], RawBoxes["\[SkeletonIndicator]"]}], obj]
					,
					"MessagesFailure",
					Interpretation[Row[{RawBoxes["\[SkeletonIndicator]"], Row[{RawBoxes["TestResultObject"], RawBoxes["["], Row[{"MessagesFailure:", " ", ActualMessages[obj]}], RawBoxes["]"]}], RawBoxes["\[SkeletonIndicator]"]}], obj]
					,
					"Failure",
					Interpretation[Row[{RawBoxes["\[SkeletonIndicator]"], Row[{RawBoxes["TestResultObject"], RawBoxes["["], Row[{"Failure:", " ", ActualOutput[obj]}], RawBoxes["]"]}], RawBoxes["\[SkeletonIndicator]"]}], obj]
					,
					"Error",
					Interpretation[Row[{RawBoxes["\[SkeletonIndicator]"], Row[{RawBoxes["TestResultObject"], RawBoxes["["], Row[{"Error:", " ", ErrorMessage[obj]}], RawBoxes["]"]}], RawBoxes["\[SkeletonIndicator]"]}], obj]
				];
			(* This prevents the Very Large Output panel from appearing in the
			front end if the parts of the TestResult are very big (such as Graphics) *)
			BoxForm`SetSizeCountRule[obj -> None];
			obj /: FailureMode[obj] := failureMode;
(* BEGIN ADDED CODE *)
			obj /: TestRawInput[obj] := rawInput;
(* END ADDED CODE *)
			obj /: TestInput[obj] := input;
(* BEGIN ADDED CODE *)
			obj /: UnevaluatadRawExpectedOutput[obj] := unevaluatedRawExpectedOutput;
			obj /: UnevaluatadExpectedOutput[obj] := unevaluatedExpectedOutput;
(* END ADDED CODE *)
			obj /: ExpectedOutput[obj] := expectedOutput;
			obj /: ActualOutput[obj] := actualOutput;
			obj /: ExpectedMessages[obj] := expectedMsgs;
			obj /: ActualMessages[obj] := actualMsgs;
			obj /: ErrorMessage[obj] := errorMsg;
			obj /: TestID[obj] := OptionValue[TestResultObject, {opts}, TestID];
			obj /: TestIndex[obj] := OptionValue[TestResultObject, {opts}, TestIndex];
			obj /: AllTestIndex[obj] := OptionValue[TestResultObject, {opts}, AllTestIndex];
(* BEGIN ADDED CODE *)
			obj /: ApplyToInput[obj] := OptionValue[TestResultObject, {opts}, ApplyToInput];
			obj /: ApplyToExpected[obj] := OptionValue[TestResultObject, {opts}, ApplyToExpected];
			obj /: InputWrapper[obj] := OptionValue[TestResultObject, {opts}, InputWrapper];
			obj /: ExpectedWrapper[obj] := OptionValue[TestResultObject, {opts}, ExpectedWrapper];
			obj /: TestFailureMessageGenerator[obj] := OptionValue[TestResultObject, {opts}, TestFailureMessageGenerator];
(* END ADDED CODE *)
			obj /: TestInputSetFunction[obj] := OptionValue[TestResultObject, {opts}, TestInputSetFunction];
			obj /: ExpectedOutputSetFunction[obj] := OptionValue[TestResultObject, {opts}, ExpectedOutputSetFunction];
			obj /: EquivalenceFunction[obj] := OptionValue[TestResultObject, {opts}, EquivalenceFunction];
			obj /: MessagesEquivalenceFunction[obj] := OptionValue[TestResultObject, {opts}, MessagesEquivalenceFunction];
			obj /: ExpectedMessagesWrapper[obj] := OptionValue[TestResultObject, {opts}, ExpectedMessagesWrapper];
			obj /: TestFailureMessage[obj] := OptionValue[TestResultObject, {opts}, TestFailureMessage];
			obj /: TestFailureAction[obj] := OptionValue[TestResultObject, {opts}, TestFailureAction];
			obj /: TestErrorAction[obj] := OptionValue[TestResultObject, {opts}, TestErrorAction];
			obj /: TestTimeUsed[obj] := OptionValue[TestResultObject, {opts}, TestTimeUsed];
			obj /: TestMemoryUsed[obj] := OptionValue[TestResultObject, {opts}, TestMemoryUsed];
			obj /: TestTags[obj] := OptionValue[TestResultObject, {opts}, TestTags];
			obj /: TestSource[obj] := OptionValue[TestResultObject, {opts}, TestSource];
			obj
		]
	]


End[]


End[]


(* ::Section:: *)
(*Public symbols protection*)


ProtectContextNonVariables[];


EndPackage[]
